---
import { getImage } from "astro:assets";
import type { ImageMetadata } from "astro";

interface Props {
	src: ImageMetadata;
	alt: string;
	widths?: {
		small?: number;
		medium?: number;
		large?: number;
	};
	sizes?: string;
	loading?: "lazy" | "eager";
	decoding?: "async" | "sync" | "auto";
	class?: string;
	fetchpriority?: "high" | "low" | "auto";
	style?: string;
	id?: string;
	title?: string;
}

const {
	src,
	alt,
	widths = { small: 640, medium: 1024, large: 1920 },
	sizes = "(max-width: 640px) 640px, (max-width: 1024px) 1024px, 1920px",
	loading = "lazy",
	decoding = "async",
	class: className,
	fetchpriority,
	style,
	id,
	title,
} = Astro.props;

// Normalize widths to ensure all breakpoints have values
const { small: smallWidth = 640, medium: mediumWidth = 1024, large: largeWidth = 1920 } = widths;

// Get original image size
const originalImage = await getImage({ src });
const originalWidth = originalImage.attributes.width;
const originalFormat = src.format || "png";
const isJpeg = originalFormat.toLowerCase() === "jpg" || originalFormat.toLowerCase() === "jpeg";
const fallbackFormat = isJpeg ? "jpg" : "png";

// Generate AVIF images for all sizes based on original size
const avifSmallWidth = Math.min(originalWidth, smallWidth);
const avifMediumWidth = Math.min(originalWidth, mediumWidth);
const avifLargeWidth = Math.min(originalWidth, largeWidth);

const avifSmall = await getImage({ src, width: avifSmallWidth, format: "avif" });
const avifMedium = await getImage({ src, width: avifMediumWidth, format: "avif" });
const avifLarge = await getImage({ src, width: avifLargeWidth, format: "avif" });

// Generate AVIF at original width for when original size is smaller than breakpoints
const avifOriginal = await getImage({ src, width: originalWidth, format: "avif" });

// Generate fallback image (use original format for JPEG, PNG otherwise)
const fallbackImage = await getImage({
	src,
	width: originalWidth < mediumWidth ? originalWidth : mediumWidth,
	format: fallbackFormat,
});

// Create AVIF srcset string based on original size
let avifSrcset = "";
let computedSizes = sizes;

if (originalWidth < smallWidth) {
	avifSrcset = `${avifOriginal.src} ${originalWidth}w`;
	computedSizes = `${originalWidth}px`;
} else if (originalWidth < mediumWidth) {
	avifSrcset = `${avifSmall.src} ${smallWidth}w, ${avifOriginal.src} ${originalWidth}w`;
	computedSizes = `(max-width: ${smallWidth}px) ${smallWidth}px, ${originalWidth}px`;
} else if (originalWidth < largeWidth) {
	avifSrcset = `${avifSmall.src} ${smallWidth}w, ${avifMedium.src} ${mediumWidth}w, ${avifOriginal.src} ${originalWidth}w`;
	computedSizes = `(max-width: ${smallWidth}px) ${smallWidth}px, (max-width: ${mediumWidth}px) ${mediumWidth}px, ${originalWidth}px`;
} else {
	avifSrcset = `${avifSmall.src} ${smallWidth}w, ${avifMedium.src} ${mediumWidth}w, ${avifLarge.src} ${largeWidth}w`;
	computedSizes = sizes;
}
---

<picture>
	<source type="image/avif" srcset={avifSrcset} sizes={computedSizes} />
	<img
		src={fallbackImage.src}
		alt={alt}
		width={fallbackImage.attributes.width}
		height={fallbackImage.attributes.height}
		loading={loading}
		decoding={decoding}
		class={className}
		fetchpriority={fetchpriority}
		style={style}
		id={id}
		title={title}
	/>
</picture>
