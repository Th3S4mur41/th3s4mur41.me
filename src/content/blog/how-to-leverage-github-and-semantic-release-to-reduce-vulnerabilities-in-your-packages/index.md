---
title: >-
  How to leverage GitHub and semantic release to reduce vulnerabilities in your
  packages
date: 2022-12-16T04:16:49.598Z
image: ''
published: true
description: >-
  Have you ever noticed, when you install your project‚Äôs dependencies, that npm
  is reporting known vulnerabilities you just installed?
tags: []
keywords: []
canonical: >-
  https://medium.com/@th3s4mur41/how-to-leverage-github-and-semantic-release-to-reduce-vulnerabilities-in-your-packages-c517403e339c
---

You most probably know from personal experience that many projects nowadays require a bunch of dependencies to develop, compile or run.

Have you ever noticed though, when you install your project‚Äôs dependencies, that npm is also reporting known vulnerabilities in those dependencies?

Even if your project is only using a handful direct dependencies, chances are that those dependencies also have transitive dependencies on their own, and so on‚Ä¶ You see where I‚Äôm going with this.

Let‚Äôs have a look at [the dependencies tree of the demo project](https://github.com/Th3S4mur41/demo-auto-security-release/network/dependencies)‚Ä¶

While the project itself ‚Äúonly‚Äù has eight (8) direct dependencies referenced in its [_package.json_](https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/package.json), the whole dependencies tree contains a total of 533 packages.

Keeping track of all those dependencies and their vulnerabilities quickly becomes a tedious if not impossible task to handle manually.

This is where [GitHub](http://github.com) can help.

_All following code snippets can be forked from_ [_the demo repository on GitHub_](https://github.com/Th3S4mur41/demo-auto-security-release)_._

### GitHub

Github recently published a list of [best practices to mitigate OWASP vulnerabilities](https://github.blog/2022-11-04-how-to-mitigate-owasp-vulnerabilities-while-staying-in-the-flow/).

One of the tips is to leverage [Dependabot](https://github.blog/2022-05-25-how-we-use-dependabot-to-secure-github/) to alert developers about known vulnerabilities in dependencies and potentially update those dependencies to a patched version.

The first step is to activate Dependabot alerts and security updates. This can be done easily in the repository settings under _Code security and analysis_ as you can see in the screenshot below.

#### Dependabot alerts

The first setting will alert you when there are known vulnerabilities in dependencies you are using like running `npm audit` would, but it will also help you to track and manage those vulnerabilities.

![](C:\src\test\medium-export\posts\md_1712848580652\img\1__yuJLNnRGx3fUZSq4klfuAQ.png)

#### Dependabot security¬†updates

The second setting will enable dependabot to try and fix the vulnerabilities automatically. If a fixed version of the dependency is available and compatible with your repository, Dependabot will open a pull request to update the affected package.

#### Dependabot version¬†updates

But why stop there? The third option, _Dependabot version updates_, will help you create a Dependabot configuration to automatically update all your dependencies as well.

The code below is the most basic Dependabot configuration to update your npm dependencies on a weekly basis and add a user or team as reviewer to all pull requests dependabot would create.

\# .github/dependabot.yml  
version: 2  
updates:  
 \- package-ecosystem: "npm"  
 directory: "/" \# Location of package manifests  
 schedule:  
 interval: "weekly"  
 reviewers:  
 \- "<user or team name>"

Version updates can be further customized in many ways following the [official dependabot documentation](https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file).

#### \[Bonus\] Keep your CI up to¬†date

While this is not directly related to your dependencies, it might help keep your CI secure too. By adding a few lines to your dependabot.yml, you can also configure it to also keep your Github Actions up to date. You just need to add a second package ecosystem with the following lines:

\- package-ecosystem: "github-actions"  
 directory: "/"  
 schedule:  
 interval: "daily"

The [demo repository‚Äôs dependabot config](https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/.github/dependabot.yml) is set to update both npm packages and Github Actions on a daily basis.

#### Auto merge Dependabot PR

In projects with a lot of dependencies, the amount of pull request generated by Dependabot can quickly become a burden to review and merge. If you have a test automation to validate your pull requests, this is something you no longer want to do manually.

‚ö†Ô∏è **Before implementing this step, make sure to setup branch protection and a CI (build, test, deploy) you can trust since you will no longer be validating those changes manually.**

Automatically merging Dependabot pull requests can be achieved by creating a workflow leveraging the Github API‚Ä¶

\# .github/workflows/dependabot-automation.yml  
name: Depandabot automation  
on:  
 pull_request_target:  
 types: \[opened, synchronize, reopened\]  
permissions:  
 pull-requests: write  
 contents: write  
jobs:  
 dependabot-auto:  
 name: 'ü§ñ Dependabot Automation'  
 runs-on: ubuntu-latest  
 \# Only run if PR was opened by dependabot  
 if: ${{ github.actor \== 'dependabot\[bot\]' }}  
    steps:  
      \- name: Dependabot metadata  
        id: metadata  
        uses: dependabot/fetch-metadata@v1  
          with:  
            github-token: '${{ secrets.GITHUB\_TOKEN }}'  
 \- name: Enable auto-merge for Dependabot PRs  
 continue-on-error: true  
 \# Auto merge dependencies with patch or minor updates  
 \# Major versions still must be merged manually  
 if: ${{(steps.metadata.outputs.update-type \== 'version-update:semver-patch') || (steps.metadata.outputs.update-type \== 'version-update:semver-minor')}}  
        run: gh pr merge \--auto \--squash "$PR_URL"  
 env:  
 PR_URL: ${{github.event.pull\_request.html\_url}}  
 \# GH_TOKEN needed to trigger follow up worlflow: https://github.com/fastify/github-action-merge-dependabot/issues/134  
 GITHUB_TOKEN: ${{ secrets.GH\_TOKEN || secrets.GITHUB\_TOKEN }}

If your branches are configured to require approval before merging, you‚Äôll also need to add the following step to the previous workflow to handle this as well.

\- name: Approve a PR  
 continue-on-error: true  
 run: gh pr review \--approve "$PR_URL"  
 env:  
 PR_URL: ${{github.event.pull\_request.html\_url}}  
 \# GH_TOKEN needed to approve PR as code owner on protected branches  
 GITHUB_TOKEN: ${{ secrets.GH\_TOKEN || secrets.GITHUB\_TOKEN }}

Alternatively, you can also rely on Github Actions like [Dependabot Auto Merge](https://github.com/marketplace/actions/dependabot-auto-merge) to simplify the workflow similar to [the solution implemented in the demo](https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/.github/workflows/on_dependabot.yml).

\# This is the workflow to automatically approve and merge dependabot PRs

#

name: Dependabot automation

on:  
 pull_request_target:  
 types: \[opened, synchronize, reopened\]

\# Allows you to run this workflow manually from the Actions tab  
 workflow_dispatch:

jobs:  
 dependabot:  
 name: 'ü§ñ Dependabot Automation'  
 runs-on: ubuntu-latest  
 if: ${{ github.actor \== 'dependabot\[bot\]' }}

    steps:
      \- uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull\_request.head.sha }}

      \- uses: ahmadnassri/action-dependabot-auto-merge@v2
        with:
          target: minor
          github-token: ${{ secrets.DEPENDABOT\_TOKEN  }}
          command: squash and merge

#### Avoiding introducing vulnerabilities with new dependencies

The Github team recently published a new action called [dependency-review-action](https://github.com/actions/dependency-review-action) that can further help reduce vulnerable dependencies by scanning pull request and blocking the addition of vulnerable dependencies before they can even make it in your code.

name: Check Dependencies

on:  
 pull_request:  
 types: \[opened, synchronize, reopened\]

permissions:  
 contents: read

jobs:  
 dependency-review:  
 name: '‚õìÔ∏è Dependency Review'  
 runs-on: ubuntu-latest

    steps:
      \- name: '‚òÅÔ∏è Checkout repository'
        uses: actions/checkout@v3

      \- name: 'üõ°Ô∏è Dependency Review'
        uses: actions/dependency-review-action@v3

With all this in place, you have already reduced vulnerabilities in your code. But until you create a new release your package is still affected.

This is often a problem for legacy packages or packages that are not actively or regularly maintained. This is not something you want to happen to your package once you move on to your next project!

### semantic-release

[semantic-release](https://semantic-release.gitbook.io/semantic-release/) is a tool that helps you automate the release process of your package, including update the version number, generating release notes and changelog and publishing the package to a registry.

#### Commit format

For semantic release to be able to determine which part of your semantic version to bump, your commits need to follow a commit convention.

In our example we use [commitlint](https://commitlint.js.org/#/) with an [extension of its default settings](https://github.com/Th3S4mur41/demo-auto-security-release/blob/main/commitlint.config.js) to make sure semantic release will be able to use them.

#### Auto release security¬†fixes

Your also need to configure semantic-release‚Ä¶

Additionally, to select which branch should trigger a release, you might also want to add a few plugins to generate release notes and a changelog, publish your package and generate a GitHub tag.

The following settings will also make sure that the generated changelog as well as the package config with the new version are committed to your repository.

{  
 "branches": \["main"\],  
 "plugins": \[  
 "@semantic-release/commit-analyzer",  
 "@semantic-release/release-notes-generator",  
 "@semantic-release/changelog",  
 "@semantic-release/npm",  
 \[  
 "@semantic-release/git",  
 {  
 "assets": \["CHANGELOG.md", "package.json", "package-lock.json"\]  
 }  
 \],  
 "@semantic-release/github"  
 \]  
}

That‚Äôs it?

Not quite. The default commit message from dependabot won‚Äôt trigger a new release, so there is still something we need to do.

[Matt Rathbun](https://www.linkedin.com/in/matthewrathbun/) wrote a [straightforward guide](https://rathbun.dev/posts/semantic-release-dependabot/#approach-2---configure-semantic-release-to-understand-dependabot-commits) to update your semantic-release configuration to automatically trigger a new patch release for dependencies update.

The configuration consists of 2 changes:

- Update the commit analyzer to release a new patch for \`build(deps)\` commits
- Update the release notes generator to include the details about those commits in the GitHub release notes

"release":  
 // ...  
 "plugins": \[  
 \[  
 "@semantic-release/commit-analyzer",  
 {  
 "preset": "conventionalcommits",  
 "releaseRules": \[  
 {  
 "type": "build",  
 "scope": "deps",  
 "release": "patch"  
 }  
 \]  
 }  
 \],  
 \[  
 "@semantic-release/release-notes-generator",  
 {  
 "preset": "conventionalcommits",  
 "presetConfig": {  
 "types": \[  
 {  
 "type": "feat",  
 "section": "Features"  
 },  
 {  
 "type": "fix",  
 "section": "Bug Fixes"  
 },  
 {  
 "type": "build",  
 "section": "Dependencies and Other Build Updates",  
 "hidden": false  
 }  
 \]  
 }  
 }  
 \]  
 // ...  
 \]  
}{

All that is left to do is to trigger semantic-release with every push on your main branch.

name: 'Semantic release'

on:  
 push:  
 branches: \[main\]

jobs:  
 \# jobs to check your code come here

release:  
 name: 'üè∑Ô∏è Release'  
 runs-on: ubuntu-latest

    environment:
      name: production
      url: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.release.outputs.version }}

    outputs:
      version: ${{ steps.release.outputs.version }}

    steps:
      \- name: '‚òÅÔ∏è Checkout repository'
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: false

      \- name: '‚öôÔ∏è Use Node.js'
        uses: actions/setup-node@v3
        with:
          check-latest: true
          cache: 'npm'

      \- name: '‚õìÔ∏è Install dependencies'
        run: npm ci \--omit=optional \--audit=false \--prefer-offline \--progress=false

      \- name: 'üì¶ Release'
        id: release
        env:
          GITHUB\_TOKEN: ${{ secrets.GITHUB\_TOKEN }}
          GH\_TOKEN: ${{ secrets.GH\_TOKEN || secrets.GITHUB\_TOKEN }} \# Needed to push to GitHub
        run: |
          npx semantic-release
          echo "::set-output name=version::$(npm run env | grep npm\_package\_version | cut -d '=' -f 2)"n::$(npm run env | grep npm\_package\_version | cut -d '=' -f 2)"

And your done‚Ä¶ Now, every time Dependabot fixes a vulnerability in your dependencies, the CI will issue a new release of your package with a fix.

### Conclusion

By combining those two tools, you can reduce the risk of vulnerabilities in your packages without spending a minute of your time‚Ä¶ I‚Äôd say, that is definitely worth spending the initial effort to do a little bit of configuration.

What do you think?

_More content at_ [**_PlainEnglish.io_**](https://plainenglish.io/)_. Sign up for our_ [**_free weekly newsletter_**](http://newsletter.plainenglish.io/)_. Follow us on_ [**_Twitter_**](https://twitter.com/inPlainEngHQ), [**_LinkedIn_**](https://www.linkedin.com/company/inplainenglish/)_,_ [**_YouTube_**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw)_, and_ [**_Discord_**](https://discord.gg/GtDtUAvyhW)**_._**

**_Interested in scaling your software startup_**_? Check out_ [**_Circuit_**](https://circuit.ooo?utm=publication-post-cta)_._
