---
import { getImage } from "astro:assets";
import { getCollection, getEntry, render } from "astro:content";
import path from "node:path";
import Layout from "../../layouts/Layout.astro";
import BlogPostingSchema from "../../components/BlogPostingSchema.astro";
import PodcastEpisodeSchema from "../../components/PodcastEpisodeSchema.astro";

/**
 * Unified dynamic route for both blog posts and talks.
 * Supports draft preview slugs prefixed with `_draft-` the same way the original
 * individual route files did. Eliminates duplicated logic (images, title truncation, meta setup).
 */
export async function getStaticPaths() {
	const collections = [
		{ name: "blog", entries: await getCollection("blog") },
		{ name: "talks", entries: await getCollection("talks") },
	];

	const paths = collections.flatMap(({ name, entries }) =>
		entries.map((entry) => {
			const base = entry.id; // original entry id (folder name / file stem)
			const isPublished = entry.data.published === true;
			const finalSlug = !isPublished && !base.startsWith("_draft-") ? `_draft-${base}` : base;
			return {
				params: { section: name, slug: finalSlug },
				props: { article: entry, section: name },
			};
		}),
	);

	return paths;
}

// Runtime params.
const { section, slug } = Astro.params as {
	section?: string;
	slug?: string;
};

const SUPPORTED_SECTIONS = ["blog", "talks"] as const;
type Section = (typeof SUPPORTED_SECTIONS)[number];

if (!section || !SUPPORTED_SECTIONS.includes(section as Section)) {
	throw new Error(`Invalid section: ${section}`);
}

// Normalize draft slug back to original entry id.
const normalizedSlug = slug?.startsWith("_draft-") ? slug.slice("_draft-".length) : slug;
if (!normalizedSlug) {
	throw new Error("Missing slug param");
}
const article = await getEntry(section as Section, normalizedSlug);
if (!article) {
	throw new Error(`Article not found: ${section}/${normalizedSlug}`);
}

// Render MD/MDX content.
const { Content } = await render(article);

// Import images from both collections eagerly (Astro will tree-shake unused).
const blogImages = import.meta.glob("/src/content/blog/**/*.{jpg,png,webp}", { eager: true });
const talksImages = import.meta.glob("/src/content/talks/**/*.{jpg,png,webp}", { eager: true });
const imagePools: Record<string, Record<string, unknown>> = {
	blog: blogImages,
	talks: talksImages,
};

function normalizePosix(p: string): string {
	return path.posix.normalize(p);
}

// NOTE: `article.data.image` may reference an image in the same folder as the post,
// but it can also reference shared assets elsewhere inside the collection (e.g. "../hero.png").
// We resolve by trying a couple of normalized candidates against the eager glob pool.
let imagePath: string | undefined;
let resolvedImage: unknown;

if (article.data.image) {
	const raw = typeof article.data.image === "string" ? article.data.image.trim() : "";
	if (raw) {
		const pool = imagePools[section];
		const cleaned = raw.replace(/^\.\//, "");
		const postDir = `/src/content/${section}/${normalizedSlug}/`;
		const collectionDir = `/src/content/${section}/`;
		const candidates = cleaned.startsWith("/")
			? [normalizePosix(cleaned)]
			: [
					normalizePosix(path.posix.join(postDir, cleaned)),
					normalizePosix(path.posix.join(collectionDir, cleaned)),
				];

		for (const candidate of candidates) {
			const mod = pool[candidate];
			if (mod && typeof mod === "object" && (mod as { default?: unknown }).default) {
				imagePath = candidate;
				resolvedImage = (mod as { default?: unknown }).default;
				break;
			}
		}
	}
}

const img =
	imagePath && resolvedImage
		? await getImage({
				src: resolvedImage as unknown as string,
				width: 1200,
				height: 630,
				format: "jpg",
			})
		: undefined;

// Title truncation logic (shared previously) - ensure max 60 chars accounting for site suffix.
const SITE_SUFFIX = "| Th3S4mur41.me";
const MAX_TITLE_LEN = 60 - SITE_SUFFIX.length;
function truncateTitle(original: string): string {
	if (!original) return original;
	if (original.length <= MAX_TITLE_LEN) return original;
	const window = original.slice(0, MAX_TITLE_LEN);
	const findLast = (chars: string) => {
		let pos = -1;
		for (const ch of chars) {
			const i = window.lastIndexOf(ch);
			if (i > pos) pos = i;
		}
		return pos;
	};
	let pos = findLast(".?!");
	if (pos !== -1) {
		return window.slice(0, pos + 1).trim();
	}
	const findLastFollowedByWhitespace = (chars: string) => {
		for (let i = window.length - 1; i >= 0; i--) {
			const ch = window[i];
			if (!chars.includes(ch)) continue;
			const nextChar = original[i + 1];
			if (nextChar && /\s/.test(nextChar)) return i;
		}
		return -1;
	};
	pos = findLastFollowedByWhitespace(":;");
	if (pos !== -1) {
		return window.slice(0, pos).trim();
	}
	pos = window.lastIndexOf(",");
	if (pos !== -1) {
		const cut = Math.min(pos + 1, MAX_TITLE_LEN - 3);
		return `${window.slice(0, cut).trimEnd()}...`;
	}
	const spacePos = window.lastIndexOf(" ", MAX_TITLE_LEN - 3);
	if (spacePos > 20) {
		return `${window.slice(0, spacePos).trimEnd()}...`;
	}
	return `${window.slice(0, MAX_TITLE_LEN - 3).trimEnd()}...`;
}

const truncatedTitle = truncateTitle(article.data.title);
// Hint to linter that these identifiers are intentionally used in the template markup below.
// This keeps zero runtime impact while satisfying static analysis.
void [Layout, Content, img, truncatedTitle, BlogPostingSchema, PodcastEpisodeSchema];
---

<Layout
  title={truncatedTitle}
  image={img}
	imageAlt={article.data.imageAlt}
  description={article.data.description}
  keywords={article.data.keywords}
  noIndex={!article.data.published}
  canonical={article.data.canonical ?? undefined}
  noHeader>
  <article>
    {article.data.eyebrow && <p class="eyebrow">{article.data.eyebrow}</p>}
    {/** Render markdown/MDX content */}
    <Content />
    <footer>
      <p class="published">
        Published on <time datetime={article.data.date}>{article.data.date.toLocaleDateString('en-gb', { year: 'numeric', month: 'short', day: 'numeric' })}</time>
        {article.data.canonical && (
          <>
            {' '}via <a href={article.data.canonical} target="_blank" rel="noopener noreferrer">
              {new URL(article.data.canonical).hostname.replace(/^www\./, '').split('.')[0]}
            </a>
          </>
        )} by <a href="/about/" class="author">MichaÃ«l Vanderheyden</a>
      </p>
      {article.data.updated && (
        <p class="updated">
          Last updated on <time datetime={article.data.updated}>{article.data.updated.toLocaleDateString('en-gb', { year: 'numeric', month: 'short', day: 'numeric' })}</time>
        </p>
      )}
    </footer>

		{section === "blog" && (
			<BlogPostingSchema
				headline={article.data.title}
				description={article.data.description}
				datePublished={article.data.date}
				dateModified={article.data.updated}
				image={img}
				url={Astro.url.href}
				canonical={article.data.canonical}
			/>
		)}

		{section === "talks" && article.data.type === "podcast" && (
			<PodcastEpisodeSchema
				name={article.data.title}
				description={article.data.description}
				datePublished={article.data.date}
				url={Astro.url.href}
				canonical={article.data.canonical}
				image={img}
			/>
		)}
  </article>
</Layout>
