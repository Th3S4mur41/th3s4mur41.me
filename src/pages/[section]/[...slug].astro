---
import { getImage } from "astro:assets";
import { getCollection, getEntry, render } from "astro:content";
import path from "node:path";
import BlogPostingSchema from "../../components/BlogPostingSchema.astro";
import PodcastEpisodeSchema from "../../components/PodcastEpisodeSchema.astro";
import Reactions from "../../components/Reactions.astro";
import RelatedArticles from "../../components/RelatedArticles.astro";
import Layout from "../../layouts/Layout.astro";
import { isPreviewFutureContentEnabled, isVisibleContent } from "../../utils/contentVisibility";

/**
 * Unified dynamic route for both blog posts and talks.
 * Supports draft preview slugs prefixed with `_draft-` the same way the original
 * individual route files did. Eliminates duplicated logic (images, title truncation, meta setup).
 */
export async function getStaticPaths() {
	const now = new Date();
	const previewFuture = isPreviewFutureContentEnabled();

	const collections = [
		{ name: "blog", entries: await getCollection("blog") },
		{ name: "talks", entries: await getCollection("talks") },
	];

	const paths = collections.flatMap(({ name, entries }) =>
		entries
			.filter((entry) => isVisibleContent(entry.data, { now, previewFuture }))
			.map((entry) => ({
				params: { section: name, slug: entry.id },
				props: { article: entry, section: name },
			})),
	);

	return paths;
}

// Runtime params.
const { section, slug } = Astro.params as {
	section?: string;
	slug?: string;
};

const SUPPORTED_SECTIONS = ["blog", "talks"] as const;
type Section = (typeof SUPPORTED_SECTIONS)[number];

if (!section || !SUPPORTED_SECTIONS.includes(section as Section)) {
	throw new Error(`Invalid section: ${section}`);
}

// Backward compat: normalize legacy draft slug back to original entry id.
const normalizedSlug = slug?.startsWith("_draft-") ? slug.slice("_draft-".length) : slug;
if (!normalizedSlug) {
	throw new Error("Missing slug param");
}
const article = await getEntry(section as Section, normalizedSlug);
if (!article) {
	throw new Error(`Article not found: ${section}/${normalizedSlug}`);
}

// Safety: even if someone hits a legacy `_draft-` URL directly, never render unpublished items.
// Future-dated items are only visible when PREVIEW_FUTURE_CONTENT is enabled at build/runtime.
const previewFuture = isPreviewFutureContentEnabled();
const isVisible = isVisibleContent(article.data, { previewFuture });
if (!isVisible) {
	throw new Error(`Content not visible: ${section}/${normalizedSlug}`);
}

// Render MD/MDX content.
const { Content } = await render(article);

// Import images from both collections eagerly (Astro will tree-shake unused).
const blogImages = import.meta.glob("/src/content/blog/**/*.{jpg,png,webp}", { eager: true });
const talksImages = import.meta.glob("/src/content/talks/**/*.{jpg,png,webp}", { eager: true });
const imagePools: Record<string, Record<string, unknown>> = {
	blog: blogImages,
	talks: talksImages,
};

function normalizePosix(p: string): string {
	return path.posix.normalize(p);
}

// NOTE: `article.data.image` may reference an image in the same folder as the post,
// but it can also reference shared assets elsewhere inside the collection (e.g. "../hero.png").
// We resolve by trying a couple of normalized candidates against the eager glob pool.
let imagePath: string | undefined;
let resolvedImage: unknown;

if (article.data.image) {
	const raw = typeof article.data.image === "string" ? article.data.image.trim() : "";
	if (raw) {
		const pool = imagePools[section];
		const cleaned = raw.replace(/^\.\//, "");
		const postDir = `/src/content/${section}/${normalizedSlug}/`;
		const collectionDir = `/src/content/${section}/`;
		const candidates = cleaned.startsWith("/")
			? [normalizePosix(cleaned)]
			: [normalizePosix(path.posix.join(postDir, cleaned)), normalizePosix(path.posix.join(collectionDir, cleaned))];

		for (const candidate of candidates) {
			const mod = pool[candidate];
			if (mod && typeof mod === "object" && (mod as { default?: unknown }).default) {
				imagePath = candidate;
				resolvedImage = (mod as { default?: unknown }).default;
				break;
			}
		}
	}
}

const img =
	imagePath && resolvedImage
		? await getImage({
				src: resolvedImage as unknown as string,
				width: 1200,
				height: 630,
				format: "jpg",
			})
		: undefined;

// Title truncation logic (shared previously) - ensure max 60 chars accounting for site suffix.
const SITE_SUFFIX = "| Th3S4mur41.me";
const MAX_TITLE_LEN = 60 - SITE_SUFFIX.length;
function truncateTitle(original: string): string {
	if (!original) return original;
	if (original.length <= MAX_TITLE_LEN) return original;
	const window = original.slice(0, MAX_TITLE_LEN);
	const findLast = (chars: string) => {
		let pos = -1;
		for (const ch of chars) {
			const i = window.lastIndexOf(ch);
			if (i > pos) pos = i;
		}
		return pos;
	};
	let pos = findLast(".?!");
	if (pos !== -1) {
		return window.slice(0, pos + 1).trim();
	}
	const findLastFollowedByWhitespace = (chars: string) => {
		for (let i = window.length - 1; i >= 0; i--) {
			const ch = window[i];
			if (!chars.includes(ch)) continue;
			const nextChar = original[i + 1];
			if (nextChar && /\s/.test(nextChar)) return i;
		}
		return -1;
	};
	pos = findLastFollowedByWhitespace(":;");
	if (pos !== -1) {
		return window.slice(0, pos).trim();
	}
	pos = window.lastIndexOf(",");
	if (pos !== -1) {
		const cut = Math.min(pos + 1, MAX_TITLE_LEN - 3);
		return `${window.slice(0, cut).trimEnd()}...`;
	}
	const spacePos = window.lastIndexOf(" ", MAX_TITLE_LEN - 3);
	if (spacePos > 20) {
		return `${window.slice(0, spacePos).trimEnd()}...`;
	}
	return `${window.slice(0, MAX_TITLE_LEN - 3).trimEnd()}...`;
}

const truncatedTitle = truncateTitle(article.data.title);
// Hint to linter that these identifiers are intentionally used in the template markup below.
// This keeps zero runtime impact while satisfying static analysis.
void [Layout, Content, img, truncatedTitle, BlogPostingSchema, PodcastEpisodeSchema];
---

<Layout
  title={truncatedTitle}
  image={img}
	imageAlt={article.data.imageAlt}
  description={article.data.description}
  keywords={article.data.keywords}
  noIndex={!article.data.published}
  canonical={article.data.canonical ?? undefined}
  noHeader>
  <article>
    {article.data.eyebrow && <p class="eyebrow">{article.data.eyebrow}</p>}
    {/** Render markdown/MDX content (TOC is injected after h1 via rehype plugin) */}
    <Content />
    <footer>
      <p class="published">
        Published on <time datetime={article.data.date}>{article.data.date.toLocaleDateString('en-gb', { year: 'numeric', month: 'short', day: 'numeric' })}</time>
        {article.data.canonical && (
          <>
            {' '}via <a href={article.data.canonical} target="_blank" rel="noopener noreferrer">
              {new URL(article.data.canonical).hostname.replace(/^www\./, '').split('.')[0]}
            </a>
          </>
        )} by <a href="/about/" class="author">MichaÃ«l Vanderheyden</a>
      </p>
      {article.data.updated && (
        <p class="updated">
          Last updated on <time datetime={article.data.updated}>{article.data.updated.toLocaleDateString('en-gb', { year: 'numeric', month: 'short', day: 'numeric' })}</time>
        </p>
      )}
      <button type="button" class="share-button hidden">
				<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256" aria-hidden="true" focusable="false">
					<path d="M176,160a39.89,39.89,0,0,0-28.62,12.09l-46.1-29.63a39.8,39.8,0,0,0,0-28.92l46.1-29.63a40,40,0,1,0-8.66-13.45l-46.1,29.63a40,40,0,1,0,0,55.82l46.1,29.63A40,40,0,1,0,176,160Zm0-128a24,24,0,1,1-24,24A24,24,0,0,1,176,32ZM64,152a24,24,0,1,1,24-24A24,24,0,0,1,64,152Zm112,72a24,24,0,1,1,24-24A24,24,0,0,1,176,224Z"></path>
				</svg>
				<span>Share</span>
			</button>

			{article.data.reactions && <Reactions reactions={article.data.reactions} />}
    </footer>

    <script>
      // Only show the share button if the Web Share API is supported
      if (navigator.share) {
        const shareButtons = document.querySelectorAll('.share-button');
        for (const shareButton of shareButtons) {
          shareButton.addEventListener('click', async () => {
            try {
              await navigator.share({
                title: document.title,
                url: window.location.href
              });
            } catch {
              // User cancelled or error occurred
            }
          });
          shareButton.classList.remove('hidden');
        }
      }

      /**
			 * A11y: Add tabindex="0" to horizontally scrollable <pre> blocks
			 * https://www.w3.org/WAI/standards-guidelines/act/rules/0ssw9k/
			 */
      function updatePreTabIndex(pre) {
        if (pre.scrollWidth > pre.clientWidth) {
          if (!pre.hasAttribute('tabindex')) {
            pre.setAttribute('tabindex', '0');
          }
        } else {
          // Remove tabindex if no longer scrollable
          if (pre.getAttribute('tabindex') === '0') {
            pre.removeAttribute('tabindex');
          }
        }
      }

      // Observe each pre element for resize events
      if ('ResizeObserver' in window) {
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            updatePreTabIndex(entry.target);
          }
        });

        document.querySelectorAll('pre').forEach((pre) => {
          updatePreTabIndex(pre);
          resizeObserver.observe(pre);
        });
      } else {
        // Fallback: just set initial tabindex without observation
        document.querySelectorAll('pre').forEach((pre) => {
          updatePreTabIndex(pre);
        });
      }
    </script>

		{section === "blog" && (
			<BlogPostingSchema
				headline={article.data.title}
				description={article.data.description}
				datePublished={article.data.date}
				dateModified={article.data.updated}
				image={img}
				url={Astro.url.href}
				canonical={article.data.canonical}
			/>
		)}

		{section === "talks" && article.data.type === "podcast" && (
			<PodcastEpisodeSchema
				name={article.data.title}
				description={article.data.description}
				datePublished={article.data.date}
				url={Astro.url.href}
				canonical={article.data.canonical}
				image={img}
				publisherName={article.data.publisherName}
				publisherUrl={article.data.publisherUrl}
			/>
		)}
  </article>
	<aside slot="aside">
		<h2>You might also like</h2>
		<RelatedArticles currentArticle={article} />
	</aside>
</Layout>
