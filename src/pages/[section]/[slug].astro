---
import { getImage } from "astro:assets";
import { getCollection, getEntry, render } from "astro:content";
import Layout from "../../layouts/Layout.astro";

/**
 * Unified dynamic route for both blog posts and talks.
 * Supports draft preview slugs prefixed with `_draft-` the same way the original
 * individual route files did. Eliminates duplicated logic (images, title truncation, meta setup).
 */
export async function getStaticPaths() {
	const collections = [
		{ name: "blog", entries: await getCollection("blog") },
		{ name: "talks", entries: await getCollection("talks") },
	];

	const paths = collections.flatMap(({ name, entries }) =>
		entries.map((entry) => {
			const base = entry.id; // original entry id (folder name / file stem)
			const isPublished = entry.data.published === true;
			const finalSlug = !isPublished && !base.startsWith("_draft-") ? `_draft-${base}` : base;
			return {
				params: { section: name, slug: finalSlug },
				props: { article: entry, section: name },
			};
		}),
	);

	return paths;
}

// Runtime params.
const { section, slug } = Astro.params as {
	section?: string;
	slug?: string;
};

const SUPPORTED_SECTIONS = ["blog", "talks"] as const;
type Section = (typeof SUPPORTED_SECTIONS)[number];

if (!section || !SUPPORTED_SECTIONS.includes(section as Section)) {
	throw new Error(`Invalid section: ${section}`);
}

// Normalize draft slug back to original entry id.
const normalizedSlug = slug?.startsWith("_draft-") ? slug.slice("_draft-".length) : slug;
if (!normalizedSlug) {
	throw new Error("Missing slug param");
}
const article = await getEntry(section as Section, normalizedSlug);
if (!article) {
	throw new Error(`Article not found: ${section}/${normalizedSlug}`);
}

// Render MD/MDX content.
const { Content } = await render(article);

// Import images from both collections eagerly (Astro will tree-shake unused).
const blogImages = import.meta.glob("/src/content/blog/**/*.{jpg,png,webp}", { eager: true });
const talksImages = import.meta.glob("/src/content/talks/**/*.{jpg,png,webp}", { eager: true });
const imagePools: Record<string, Record<string, unknown>> = {
	blog: blogImages,
	talks: talksImages,
};

// NOTE: For draft slugs, the folder on disk is named by the normalized slug (without _draft-).
// The original implementation used the route `slug` (which could include _draft-) when building image paths,
// which would fail if the folder did not actually have that prefix. We correct this by using `normalizedSlug`.
const imagePath = article.data.image ? `/src/content/${section}/${normalizedSlug}/${article.data.image}` : undefined;

let resolvedImage: unknown;
if (imagePath) {
	const pool = imagePools[section];
	const mod = pool[imagePath];
	if (mod && typeof mod === "object" && (mod as { default?: unknown }).default) {
		resolvedImage = (mod as { default?: unknown }).default;
	}
}

const img =
	imagePath && resolvedImage
		? await getImage({
				src: resolvedImage as unknown as string,
				width: 1200,
				height: 630,
				format: "jpg",
			})
		: undefined;

// Title truncation logic (shared previously) - ensure max 60 chars accounting for site suffix.
const SITE_SUFFIX = "| Th3S4mur41.me";
const MAX_TITLE_LEN = 60 - SITE_SUFFIX.length;
function truncateTitle(original: string): string {
	if (!original) return original;
	if (original.length <= MAX_TITLE_LEN) return original;
	const window = original.slice(0, MAX_TITLE_LEN);
	const findLast = (chars: string) => {
		let pos = -1;
		for (const ch of chars) {
			const i = window.lastIndexOf(ch);
			if (i > pos) pos = i;
		}
		return pos;
	};
	let pos = findLast(".?!");
	if (pos !== -1) {
		return window.slice(0, pos + 1).trim();
	}
	const findLastFollowedByWhitespace = (chars: string) => {
		for (let i = window.length - 1; i >= 0; i--) {
			const ch = window[i];
			if (!chars.includes(ch)) continue;
			const nextChar = original[i + 1];
			if (nextChar && /\s/.test(nextChar)) return i;
		}
		return -1;
	};
	pos = findLastFollowedByWhitespace(":;");
	if (pos !== -1) {
		return window.slice(0, pos).trim();
	}
	pos = window.lastIndexOf(",");
	if (pos !== -1) {
		const cut = Math.min(pos + 1, MAX_TITLE_LEN - 3);
		return `${window.slice(0, cut).trimEnd()}...`;
	}
	const spacePos = window.lastIndexOf(" ", MAX_TITLE_LEN - 3);
	if (spacePos > 20) {
		return `${window.slice(0, spacePos).trimEnd()}...`;
	}
	return `${window.slice(0, MAX_TITLE_LEN - 3).trimEnd()}...`;
}

const truncatedTitle = truncateTitle(article.data.title);
// Hint to linter that these identifiers are intentionally used in the template markup below.
// This keeps zero runtime impact while satisfying static analysis.
void [Layout, Content, img, truncatedTitle];
---

<Layout
  title={truncatedTitle}
  image={img}
  description={article.data.description}
  keywords={article.data.keywords}
  noIndex={!article.data.published}
  canonical={article.data.canonical ?? undefined}
  noHeader>
  <article>
    {/** Render markdown/MDX content */}
    <Content />
    <footer>
      <p class="published">
        Published on <time datetime={article.data.date}>{article.data.date.toLocaleDateString()}</time>
        {article.data.canonical && (
          <>
            {' '}via <a href={article.data.canonical} target="_blank" rel="noopener noreferrer">
              {new URL(article.data.canonical).hostname.replace(/^www\./, '').split('.')[0]}
            </a>
          </>
        )} by <a href="/about/" class="author">MichaÃ«l Vanderheyden</a>
      </p>
      {article.data.updated && (
        <p class="updated">
          Last updated on <time datetime={article.data.updated}>{article.data.updated.toLocaleDateString()}</time>
        </p>
      )}
    </footer>
  </article>
</Layout>
